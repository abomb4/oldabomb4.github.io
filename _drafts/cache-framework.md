---
layout: post
title:  "缓存框架需求与设计"
categories: Java
date: +0800 2018-02-24 15:13:00
tag: java cache redis ehcache
---

* content
{:toc}

# 简介
--------------
缓存是一种放在请求方与数据源之间的存储机制，它对调用方提供比原数据源更快的速度。

缓存是一个比较通用的课题，在较大的项目中，我们对缓存系统的要求会越来越高，
包括但不限于存取数据、缓存过期机制、缓存手动管理等特性。

这里记录一些关于我们常用的缓存框架的功能需求，与缓存框架的设计思路。


# 名词定义
---------------
- 缓存框架：提供给Java应用程序使用，用于操作缓存的开发框架
- 缓存产品：缓存的具体实现，比如`EhCache`、`Redis`、`Memcache`


# 缓存需求
--------------
无论在项目的什么阶段，我们对缓存总是有很多需求的，而不单单是简单的存取刷新。

基本的功能需求包括：
1. 按key保存（覆盖保存）
1. 按key读取
1. 按key消除
1. 缓存分组
1. 按分组消除
1. 更改缓存产品

扩展的功能需求包括：
1. 设置缓存过期策略
1. 缓存监控与统计
1. 二级缓存

## 按key保存、读取、消除
----------------
这是所有缓存系统必须拥有的功能。
正常情况我们只需要保存功能（覆盖保存）和读取功能即可。

缓存清除按key删除功能一般在缓存的数据不正常时会使用，其余情况使用不多。

而非覆盖保存我们大多数情况下不会需要。

## 缓存分组、按分组消除
-----------------
缓存分组功能一般用于批量清空缓存。比如用户数据在数据库正面发生数据迁移或更新，
没有经过应用系统，造成缓存中的用户数据都不正常了，此时可以把“用户”分组的缓存都清空。

如果没有分组功能，则我们需要一个“条件清空”功能，或“全部清空”的功能来满足需求。

使用条件清空功能，当想要清空某类数据时，删除所有`groupName_key`的值。

不过这些功能可以不在应用系统中使用，在缓存管理系统中存在即可。

## 更改缓存后端
-------------
这是一个对缓存框架的需求，因为我们有朝一日可能会将系统中`Redis`缓存统一更改成`Couchbase`或`Memcache`。

这种切换不应该对应用系统的现有代码造成大量改动。

## 设置缓存过期策略
--------------
目前我能想到有几种策略需求：
1. 过期策略
1. 缓存大小限制

**过期策略** `LRU`, `FIFO`, `LFU` 等。
**缓存大小限制** 这个需求用在JVM缓存上，比如`EhCache`。当缓存过大，我们则需要执行删除策略，如
“将最大的缓存数据删掉”，或“将最旧的缓存删掉”，或其他什么逻辑来释放缓存空间。
主要用来防止JVM缓存过大导致堆内存不足。

## 监控与统计
---------------
监控与统计分为两个部分。
- 一部分在缓存框架上面，记录单个应用对缓存的操作记录。
- 另一部分在缓存产品上，对整体缓存情况做一个完整统计。

缓存框架上的监控与统计，对于排查应用与缓存之间的问题很有帮助，
例如每次从`Redis`上取数据的耗时和从`MySQL`上查数据的时长差不多，那么我们就要考虑缓存的必要性了。


## 结论
----------------
所以，缓存框架要支持：
1. kv增删查改
1. 缓存分组
1. 多后端支持
1. 支持二级乃至多级缓存
1. 支持缓存使用情况统计
1. 单条缓存有效期
1. 整体缓存有效期默认值

缓存产品要支持：
1. 缓存总大小
1. 缓存过期策略
1. 监控与统计

当前的缓存产品已经比较成熟，支持都很完整，但缓存框架千差万别，用法上有很多不同，

此时需要我们有选型或自行开发缓存框架的能力。

# 缓存框架选型
---------------
流行的缓存框架有`Spring Cache`、OSChina `j2Cache` 等。

## Spring Cache
-------------------
`Spring Cache` 是一套缓存框架，包含在`spring-context`包中。
对使用者来说，它主要抽象出两个接口：`CacheManager` 和`Cache`。

`Cache`接口是客户端主要操作的接口，它提供`get`、`put`、`evict`、`clear`接口。

客户端要获取`Cache`对象，需要通过`CacheManager`。
`CacheManager` 是通过`name` 来管理一大堆`Cache`对象的。

一般用法是，我们在Spring xml或java配置中，注册一个实现`CacheManager`接口的实现类，
然后通过`@Cacheable`、`@CacheEvict`等注解来实现缓存。

也可以通过Spring Bean容器 获取`CacheManager` 实例，来自行调用操作缓存。

该框架的优点：
1. 支持广泛。隶属于Spring框架，业界有广泛的支持，各种缓存都能简单集成
1. 扩展性好。组合自由，扩展方便，还可以自行实现缓存实现类
1. 开发简便。一旦完成了配置，使用非常简便，添加注解即可实现缓存
1. 代码侵入低。使用了代理技术，仅仅需要添加注解，而不用将缓存逻辑写入业务代码

缺点：
1. 配置太过自由。要求框架搭建人员对Spring 和Spring Cache 很熟悉，才能成功搭建，
    并且这东西配置不正确时，很多时候没有报错

1. AOP。 有时需要在类方法上使用缓存，这是会用到CGLib代理，但使用CGLib代理对类的写法是有要求的。
    此时必须在业务类中用Bean 容器获取`CacheManager`的方法处理缓存。

1. 对Spring版本依赖。Spring 4 中的`@Cacheable`类有一个方法是`String cacheManager() default "";`，
    可以指定使用哪一个`CacheManager`。利用这个特性（大概）可以实现二级缓存。
    但是Spring 3 中没有这个方法。
    不幸的是，我所在公司有一套框架，是基于Spring 3 的，升级Spring会导致一些奇怪的问题。

1. 注解方式无法指定反序列化类型，使用Json缓存时，很多缓存的实现都需要在缓存Json中添加`@Class`属性才能正确反序列化

所以可以利用这套接口，在应用层注入`CacheManager`，自行实现不同name的`Cache`实现，
来决定不同数据的不同序列化类型。

## j2cache

TODO

## 结论
